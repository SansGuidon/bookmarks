[Short Developer Personality Test](https://www.surveygizmo.com/s3/1900187/Short-Developer-Personality-Test)

# Quiz Score
Thanks for taking the quiz! Aggregate community results will be shared in the coming weeks, but this personality test will be open indefinitely so that it can keep telling users their programmer personality for months to come!  Share the links wherever you want:

* Full Personality Test: http://bit.ly/1uSzyss
* Short Personality Test: http://bit.ly/11iHWWH

Below each result you'll see a description for the two dichotomy traits.

# Here are your results!

## Independent vs Collaborative
You are **Collaborative**!

### Independent:
You prefer to spend most of your time working in an isolated environment.  You rarely want to collaborate because you have a better chance of solving problems on your own.  If you do have to collaborate on the direction of a project, you dislike it when you have to defend your position or when others try to muddy your plans for the project.  It's better to have one strong vision for a project from the lead programmer on that project.  Having a large team or allowing others to have significant control over the project risks communication errors, a muddied code base, and inefficiencies.  If one developer has a firm grasp on the entire codebase, they'll be much better at fixing and improving it quickly.

### Collaborative:
Good code doesn't happen in a vacuum.  You need a team to keep you energized and on your toes so that you're constantly improving the project code using the entire team's varied experience and strengths.  You like to talk frequently with colleagues and discuss ideas so that you can learn from others and spark ideas.  It doesn't matter what their experience level is, you can always learn something by including everyone.  A solo coder can't possibly code a large software project with the speed and quality that a team can.

## Abstract vs Low-Level
You are **Abstract**!

### Abstract:
You prefer to write in languages and frameworks that simplify development as much as possible and use as few characters and lines of code as possible. The trajectory of software development has always been toward making life easier and error-free. Programming has always been about adding more abstraction layers to simplify tasks, so why not trust the technology on your layer and don't worry about handling the lower layers?

### Low-Level:
The more abstraction tools and high-level languages we build, the further we get from understanding and controlling the deeper components in our programs.  This means lower performance and endless bug searches.  Developers today need to have a stronger understanding of compilers, memory management, pointer arithmetic, and other low-level topics.
## Frontier vs Conservative
You are **Conservative**!
### Frontiers:
You like to work at the cutting edge.  Using too many old languages and technologies bores you, and it severely hinders your software's potential to keep outdated technologies in it for too long. Developers need keep their ears to the ground for new technologies and new versions of tools that they already use.  Even if the community and maturity of the project isn't at a level that most enterprises would consider "safe," you're willing to be an early adopter if you believe the community and the technology has momentum.  Development technology is changing faster every day, and we need to constantly be adopting new tools and methods to keep up.

### Conservative:
It seems like every 10 years we forget all the problems we solved in the previous decade and start to build 'new' tools that solve the same problems, even though there is a perfectly good solution that has existed for years.  Enterprises have it right when they make conservative decisions about their technology stack. Why would you hang your business on a technology with only a few years of maturity in just a handful of production use cases?  Technologies like PHP, Java, and SQL have been mainstays of the development industry for years, and it takes a lot of time for new technologies to make it into that maturity tier.
 
## Generalist vs Specialist
You are a **Generalist**!
### Generalist:
You like to be known as a "Jack of all Trades" and a reference for others on your team. You jump at every chance to enhance your skills in a wide variety technology topics, not just the ones that apply to your day to day work.  You don't always know when it might be useful to have these extra skills, but when the time comes, you are ready.  If more developers took the time to learn other skills outside of the ones relevant to their project, they'd work more seamlessly with the rest of their organization because they'd have more empathy and understanding of the challenges that their colleagues face.

### Specialist:
If you're a Jack of all Trades, you're a master of none. Mastery in one or two areas is what makes you valuable.  What's the point of learning skills for other jobs you don't have and can't control? When you plan for a project or do technical research, it's always focused on something you're working on. You don't get side-tracked. If you learn a new skill, it's because the project requires that you do it. Most or all of your hobby projects are also building your mastery of the skills you use at your job.
## Idealist vs Pragmatist
You are **Pragmatic**!
### Idealist:
You believe in the power of well-defined processes. It's crucial to an organization's success that they create and follow appropriate and effective processes for building software. Trying to improvise or play it by ear invites the possibility of workflow errors that can decrease the quality of the software or even cause major product failures. Planning is also extremely important to you.  You like to research all of the things you will need to know before starting a project.  It's important to find out the best architecture for your software beforehand, and then strictly implement that architecture with objective best practices.  The more planning and scaffolding you do in the beginning, the less overall work you will have to do to complete the software.

### Pragmatist:
Speed is your best weapon in a competitive industry, and to quickly prototype and build new products, you need to have a flexible, pragmatic process.  You don't have a few months to plan your projects, you need to just start coding and a good path for the project will reveal itself.  Great products are made through frequent feedback and releases, so why shouldn't your plan be just as adaptable? Your plan should be adapted to changes in the software, and your expertise should be adapted to the project. You shouldn't spend your precious time studying a problem that you're not certain to run into while coding your projects.  Trying to build test coverage for every possible scenario and having long meetings throughout the process are a waste of time and distract you from doing more productive work.
